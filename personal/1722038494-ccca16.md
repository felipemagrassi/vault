---
id: 1722038494-ccca16
aliases:
  - ccca16
tags:
  - courses
  - engineering
---

# ccca16

## Codigo Limpo

- Quanto mais incerto for o contexto, mais dificil vai ser a estimativa do projeto
- Alta Rotatividade relacionada a Má qualidade do codigo
- Comportamento x Estrutura
  - Comportamento: O que faz o software ganhar dinheiro
  - Estrutura: O que mantém o comportamento
  - Quanto mais comportamento, mais estrutura é necessária.
  - Adicionar comportamentos mantendo a estrutura atual
- Maior competitividade do mercado cria a necessidade de softwares mais capazes e mais baratos, um bom código gera mais velocidade de adaptação e melhorias

## Refactoring

- Refatorar: Facilitar o entendimento do software, alterando a estrutura interna sem alterar o comportamento dele.

  - Quanto menos um software é refatorado, maior o consumo de tempo da equipe.
  - Tornar o software mais competitivo

- Code Smells: Sintomas de um software que podem ser usados como indicadores de problemas ( Evita a necessidade de um refactoring futuro )

## Testing

- Provam e garantem que dada um certa estrutura, um comportamento é realizado. Garantem que o seu trabalho faz o que voce deseja que ele faça
- Testes automatizados nao garantem regressão e ninguem consegue manter todos os casos de uso
- Geram coragem de refatorar o código.
  - Porque refatorar? [Refactoring](#refactoring)
- Design e Arquitetura da aplicação nao facilitam a criação de testes
  - Subir o rails para rodar testes no RSpec
- Maior parte das codebases não tem unidades independentes
  - Mockar DB == Acoplar com banco falso
- Disciplina > Experiencia e Conhecimento Tecnico em testar

- FIRST:
  - Fast: Rapidos
  - Independent: Executados de forma isolada
  - Repeatable: Mesmo resultado independente da quantidade de vezes que seja executado
  - Self-validating: Saida bem definida que é valida ou nao fazendo com que ele passe ou falhe
  - Timely: Antes do codigo fonte

- TDD laws
  - Nao escrever nenhum codigo até ter escrito um teste que detecte uma possivel falha
  - Nao escrever mais testes de unidade do que o suficiente para detectar a falha
  - Voce nao pode escrever mais codigo do que o suficiente para passar nos testes

- Só conseguir testar com patterns como mock ou stub significa que o design do codigo precisa melhorar

- Diferenças são mais pela quantidade de camadas testadas do que pelas dependencias ( usando mocks ou fakes )
- Custo inversamente proporcional com a velocidade

### Unidade

- Rapidos, Estaveis e Resistentes
  - Motor, Roda, Embreagem...
- Sociaveis vs solitarios: Podem testar apenas uma unidade ou pequenas unidades (agregadores e value objects vs testar apenas o value object)

### Integração

- Testam camadas diferentes
- Uso de test patterns não torna o teste de unidade
- Narrow vs Broad:
  - Broad: Use versões "live" dos serviços, exercita o caminha do codigo em todos os serviços, não apenas a responsabilidade do codigo. Requer acessos de rede e melhor ambiente de testes
  - Narrow: Usa apenas uma porção do código real. Abusando de test doubles no meio do processo e garantindo suporte por testes de contrato para garantir a fidelidade do test double utilizado.

### E2E

- Replicam o ambiente do Driver final

### Test Double

- Test double é um padrao que tem o objetivo de substituir um DOC (depended-on component), por performance ou segurança
- Test Doubles:
  - Dummy: Objeto para completar uma lista de parametros, ex: Signup({}) => dummy = {}
  - Stub: Objeto que retorna uma resposta pre-definida, definida para um determinado teste (passar por cima)
  - Spy: Objeto que "monitora" se algo foi utilizado da maneira correta, podendo ser verificado posteriormente
  - Mock: Objeto programado para corresponder as expectativas e monitorar se elas foram atendidas
  - Fake: Objetos que tem implementaçoes que simulam o funcionamento da instancia real
  - Configurable:
  - Hard-Coded

## Arquitetura Hexagonal

- Contexto:
  - Baixa reutilizabilidade de códigos ( Usecases acoplados a um controller HTTP, só consigo calcular os juros por 1 usecase)
  - Dificuldade na testabilidade de códigos de negocios ( UI, negocios, Bancos de dados, HttpServer acoplados)

- Drivers Side
  - Test Case
  - Human
  - Message Queue
  - Page APP

- Resources Side
  - Bancos de dados
  - SMTP
  - Message Queue
  - Repository

- Aplicaçao pode ser igualmente movida por usuarios, testes ou scripts e testada e desenvolvida isoladas de eventuais recursos externos
- Acoplamento não é necessario apenas para substituir, mas sim para gerar melhores testes e mais possibilidades de recursos diferentes.
- Não tem relaçao com dominios
- Contratos para desacoplamento ( interfaces em linguagens tipadas, testes em linguagens dinamicas )
